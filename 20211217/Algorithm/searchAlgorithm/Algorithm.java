

import java.util.ArrayList;
import java.util.Arrays;
public class Algorithm {
    static int[] arr = {1,21,7,5,6,10,2};
    
    static int Algorithm(int key, int head, int tail) {
        Arrays.sort(arr);  // 1 2 5 6 7 10 21
        int c;

         while (head <= tail) {
          c = (head + tail) / 2;

         if (arr[c] == key) {
              return c;

         } else if (arr[c] > key) {
             tail = c - 1;        
         } else {
             head = c + 1;
         }
    }
     return -1;
    }

    public static void main(String[] args) {

        int a = Algorithm(6, 0, arr.length -1);
        if (a == -1) {
            System.out.println("찾지 못했습니다.");
        } else {
            System.out.println(a + "번째 요소와 일치");
        }          
        }       
    }



// int[] arr = {11,13,17,19,23,29,31};
//     int head = 0;
//     int tail = arr.length -1;
//     int c = (head + tail) / 2;

//     if (arr[c] == 6) {
//         System.out.println(c + "번째 요소와 일치");
//     } else if (arr[c] < 6) {
//         head = c + 1;
//     } else if (arr[c] > 6) {
//         tail = c - 1;
//         if (head <= tail) {
//             c = (head + tail) /2;
//         } else {
//             System.out.println("찾지 못했습니다.");
//         }
//     } 

//     }
    

// }


// 이진 탐색법(바이너리 서치) - 범위를 절반씩 추려가면서 찾는다.
// 대상은 미리 오름차순이나 내림차순으로 정렬되어 있어야 한다.
// 1. 가운데 요소를 선택하는 처리
// 2. 가운데 데이터와 원하는 데이터를 비교하는 처리
// 3. 탐색 범위를 절반으로 좁히는 처리
// 짝수의 배열일 경우 2로 나누고, 홀수일 경우 처음과 끝을 더한 후 2로 나눌 수 있다.
// 가운데를 계산하기 위해 필요한 변수는 3개 (head + tail) / 2  인덱스 값의 head + tail 이다.
// 0~5요소일 경우, 2.5가 나오는데, 0.5는 버린다.






//     int[] arr = {1,21,7,5,6};
    

//     for (int i = 0; i < arr.length; i++) {
//         if (arr[i] == 5) {
//             System.out.println(i + "번째 요소가 일치");
//             break;
//         } else if (i == arr.length -1) {
//             System.out.println("찾지 못했습니다");
//         }
//     } 
//  } 
// }
// 
// 선형 탐색법(리니어 서치) - 앞부터 순서대로 찾는다. 탐색 효율은 그다지 좋지 못하다.
//                          탐색 처리는 반복 구조(종료 조건을 잊지 말자)로 기술한다.












// public static void main(String[] args) {
//     int[] arr = {12, 13, 11, 14, 10};

//     int max = 0;
//     for (int i = 0; i < arr.length; i++) {
//         if (arr[i] > max) {
//             max = arr[i];
//         }
//     }
//     System.out.println(max); 
//     }
// }
// // 배열에서 큰 숫자 출력


//     public static void main(String[] args) {
//         int[] arr = {12, 13, 11, 14, 10};

//         int sum = 0;

//         for (int i = 0; i < arr.length; i++) {
//             sum += arr[i];
            
//         } System.out.println(sum);
//     }
// }








//         int A = 11;
//         int B = 55;
//         int w = 0;
//         w = A;
//         A = B;
//         B = w;

//         System.out.println(A);  // 55 
//         System.out.println(B);  // 11
//     }
// }
//  A와 B를 서로 바꾸기




    //     Scanner sc = new Scanner(System.in);
    //     System.out.println("비교할 값 a와 b를 입력하세요 : ");

    //     double a = sc.nextDouble();
    //     double b = sc.nextDouble();

    //      if (a > b); {
    //         System.out.println("a가 크다.");
    //     } else if (a == b) {
    //         System.out.println("a는 b와 같다.");
    //     } else {
    //         System.out.println("b가 크다.");
    //     }
        
    //     }
    // }





//         Scanner sc = new Scanner(System.in);
//         System.out.println("삼각형 밑변 길이와 높이를 입력하세요 : ");

//         double b = sc.nextDouble();    // 실수가 들어올 수 있으니 double 자료형을 사용한다.
//         double h = sc.nextDouble();
//         double area = (b*h)/2.0;

//         System.out.println("삼각형의 면적은 " + area + "입니다.");
    
//     }
// }

/*
알고리즘 Algorithm
     알고리즘은 '문제나 과제를 해결하기 위한 처리 절차를 하나하나 구체적인 순서에 따라
     표현한 아이디어나 생각'을 말한다. ('절차'라고 할 수 있다.)
     알고리즘 자체는 일상생활에서도 많이 사용되고 있다.
     요리의 레시피, 음악의 악보, 가전제품 등의 사용 설명서는 알고리즘의 예다.
     (알고리즘(아이디어, 생각)이 표현된 것이라고 볼 수 있다.)
     사람을 위한 알고리즘은 문자나 기호, 일러스트 등으로 나타낸다.
     
     알고리즘을 프로그래밍 언어로 기술하면 프로그램이 된다.
     프로그래밍 언어는 컴퓨터에 지시하기 위한 인공 언어이다.
     아이디어와 생각, 이 알고리즘을 컴퓨터에게 전달하기 위한 방법에 대해 알아보자.

     컴퓨터가 실행하기 원하는 내용을 상세하게 분해한 후 그 구체적인 방법을 지시해 둔다.
     프로그램의 작성은 기획 > 설계 > 프로그래밍 > 디버깅 > 문서 작성
     알고리즘은 '설계' 단계에서 필요하다. 프로그램의 품질은 알고리즘의 좋고 나쁨에 달렸다.
     알고리즘이 정해진 후 프로그래밍하는 것을 '코딩'이라고 한다.

     디버그(해충제거) 과정 중 알고리즘이 확실하게 짜여 있다면 명확하게 디버깅할 수 있지만
     설계에 문제가 있었다면 다시 알고리즘으로 돌아가야 한다.

     좋은 알고리즘은?
      1. 알기 쉽다.
         수정하거나 기능을 추가할 때 그것을 만든 본인조차 이해하지 못하는 불상사가 생길 수 있다.
     
      2. 속도가 빠르다.

      3. 효율적이다.
         프로그램을 실행할 때 사용하는 메모리의 영역이 작다라는 것을 의미한다.
         프로그램의 효율이 나쁘면 대량의 메모리가 필요하기 때문에 이왕이면 효율적인 알고리즘이
         좋은 알고리즘이라고 할 수 있다.

      4. 재사용이 쉽다.
         과거에 작성한 프로그램을 그대로 사용하거나 부분적으로 이용하는 비율이 증가하면
         새로운 프로그램을 작성하는 시간이 줄어든다. 가능한 한 재사용이 쉽고,
         범용성이 높은 알고리즘을 고려하면 프로그램을 재사용할 가능성이 높아진다.

     왜 알고리즘을 공부해야 할까?
         좋은 프로그램을 만들기 위해 (빠르고, 효율적이며, 범용성이 높아야 한다.)
         프로그램의 좋고 나쁨을 구분하기 위해
         작성 과정 전체를 효율화하기 위해
         프로그래밍 기술을 향상시키기 위해

     절차가 알고리즘이기 위한 조건
         정확한 결과를 얻을 수 있어야 한다.
         반드시 종료되어야 한다.


     알고리즘의 세 가지 기본형
         순차 구조
             1. 슈퍼마켓에 간다.
             2. 당면을 산다.
             3. 집으로 돌아온다.

         선택 구조 (if)

         반복 구조(while,for)
         컴퓨터는 반복 처리에 최적화되어 있다.


     순서도(flow chart)
         도형 기호를 사용하여 알고리즘을 기술한다.
         
        

     알고리즘은 크게 탐색, 정렬, 수치 계산
         탐색 알고리즘 : 원하는 데이터를 찾아내는 알고리즘이다. 검색 엔진도 탐색 알고리즘을 사용한다.
             선형 탐색법(리니어 서치) - 앞부터 순서대로 찾는다. 탐색 효율은 그다지 좋지 못하다.
                                      탐색 처리는 반복 구조(종료 조건을 잊지 말자)로 기술한다.

             이진 탐색법(바이너리 서치) - 범위를 절반씩 추려가면서 찾는다.
                                        대상은 미리 오름차순이나 내림차순으로 정렬되어 있어야 한다.
                                        1. 가운데 요소를 선택하는 처리
                                        2. 가운데 데이터와 원하는 데이터를 비교하는 처리
                                        3. 탐색 범위를 절반으로 좁히는 처리

             해시 탐색법 - 계산해서 저장 위치를 찾는다.
                          데이터를 찾는 탐색 알고리즘 중 하나다.
                          탐색하기 쉽게 미리 함수를 사용하여 데이터를 보관해 둔다.
                          보관하는 데 사용한 함수를 사용하여 한 번에 데이터를 탐색한다.
                          데이터의 '내용'과 저장한 곳의 '요소'를 미리 연계해 둠으로써
                          짧은 시간 안에 탐색할 수 있도록 고안된 알고리즘이다.

                          0~6까지의 방(7개)에 4개의 숫자 (11,15,23,26) 넣는다고 하면,
                          방의 갯수로 나누면, 
                          11 % 7 = 4
                          15 % 7 = 1
                          23 % 7 = 2
                          26 % 7 = 5
                          이제 각 공을 나머지값과 같은, 방에 넣어두자
                          0   1   2   3   4   5   6(방)
                              15  23     11   26       

                          해시(hash)라는 단어는 '잘게 썬다'라는 의미
                          해시 탐색법으로 공을 찾는 방법
                          찾고 있는 공의 숫자 % 7 (방의숫자) = 4(공이 들어 있는 칸의 번호)

                          배열을 두 개 준비한다.
                          arrayD = {12,25,36,20,30,8,42} (7개) 해시 함수를 사용하여 별도의 배열에 다시 저장한다.
                          arrayH = {[0]~[10]} (11개) arrayH의 모든 요소를 0으로 초기화해 둔다.
                                    이 두 번째 배열은 클수록(1.5 ~ 2배 정도) 좋다. 그래야 겹치지 않는다.
                                    (너무 많을 경우 메모리의 사용량이 늘어나기 때문에 알고리즘의 효율성이
                                     떨어진다.)

                                    D의 요소를 H의 숫자만큼 나눈 나머지 숫자의 방에 넣어두자
                                    D요소의 0번째 요소는 H배열에 1번째 요소에 담긴다. 그러면 해시값은 1이 된다.

                                    D요소의 1번째 요소부터 나눈 후 H배열에 넣을 때 중복이 되는 경우가 발생할 수 있다.
                                    arrayH[1]의 값이 0이 아닌지의 여부를 확인하면 된다.
                                    arrayH[k] = 0이 참일 경우, 거짓일 경우

                                    int k = arrayD[0] % 11
                                    arrayH[k] = 0일 경우 arrayH[k] = arrayD[0]  

                                    이미 들어있는 요소와 충돌이 발생하면 H요소를 들려도 겹치게 될 것이다.
                                    arrayH[k] != 0 이럴 경우 k += 1;  하나씩 늘려준다. 찾을 때도 동일하다.
                                    arrayH[k + 1] = 0 이 나올 때까지 1씩 증가시켜서 넣어준다.
                                    
                                    계속 증가했음에도 모두 0이 아닐 경우, k가 10을 넘을 경우(자릿수)
                                    다시 처음으로 돌아와 빈 요소를 찾는다.

                                    찾는 방법
                                    해시값(arrayH의 첨자)
                                    
                                    찾고 있는 데이터가 요소의 데이터와 일치하지 않는 경우에는



         정렬 알고리즘 : 내림차순, 오름차순
           검색 엔진이나 엑셀에서도 중요하다.
             단순 정렬법 - 최소,최대값을 선택하여 앞으로 순서대로 나열한다.
                          배열 중 가장 작은(큰 것)을 선택하여 앞(뒤)으로 보낸다.
             단순 교환법 - 옆에 있는 데이터를 교환하면서 자리를 바꿔 나열한다.
             단순 삽입법 - 
             퀵 정렬

         수치 계산
          







*/