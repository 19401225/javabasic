
관계형 DB와 SQL

기업에서 가장 많이 사용되는 DB, 그리고 관계형 DB

데이터는 21세기의 원유라고 표현한다. 그만큼 잠재가치가 크다.

머신러닝은 이번에, 세상에서 3번째 등장한 개념이다.
그동안 데이터가 쌓이지 않았었고 컴퓨팅 파워가 부족했기 때문에 주목받지 못했다.
사람이 인공지능을 개발하고 사람이 컴퓨터 칩을 만들고
그러나 이제는 컴퓨터가 컴퓨터를 만드는 세상이 오고 있다.

과거에는 데이터가 일부 전문가들만 다루는 영역이었고 일반인에게는 생소한 개념이었다.
그러나 지금은 대용량 처리 기술, 인터넷 발달로 빅데이터의 시대가 도래하였다.

페이스북, 한 시간 만에 전 세계에서 어마어마한 데이터를 수집/보관/관리하고
요청하면 바로 꺼내서 활용할 수 있는 데이터들이 매순간 쌓이고 있다.

이제는 IT전문가들 뿐만 아니라 영업관리자, 마케터, 서비스 기획자 등 비전공 실무자들도
데이터 분야에 관심을 갖게 되었다.

제품 구매를 유도하기 위해
마트에서 사람들의 나이, 성별 등 그들의 동선을 파악 후
가는 길목에 살만한 물건들을 배치하는 등 
(아기 기저귀 옆에 콜라를 놓고, 계산대 옆에 맥주를 놓고,)
데이터를 분석하여 다양한 전략을 세울 수 있다.

여러분이 영업팀에 근무한다고 가정했을 때 매출 데이터와 분석 결과로 보고서를 작성해야 하는 경우
우선 데이터가 있어야만 하고, 그 데이터를 수집/보관/관리하고 다룰 수 있어야 한다.
이 데이터를 다룰 수 없다면,
1. 관련 부서(IT부서)에 요청하고
2. 직접 DB에서 구해야 한다.
그러나 서로의 업무에 대한 이해가 부족하다보니 원하는 형태로 데이터를 받을 수 없게 되는 경우가 많다.
DB에 대한 요청을 반복해야 할 경우 불필요한 시간을 많이 소모하게 될 것이다.
SQL을 알고 있다면 단 몇 줄의 쿼리문을 사용하여 원하는 데이터를 몇 분 안에 추출할 수 있다.

데이터 분석 과정
(개발자는 데이터 분석도, 이것도 저것도 해야 한다.)
R은 데이터 분석만 가능하다. 그러니 R도 하고 Python도 하고 다 배워야만 한다.


1. 문제인식
2. 데이터 수집/가공 (SQL/전처리) 
3. 데이터 분석(R/Python) (java로 분석할 수 있는 솔루션이 있지만 Python이라는 좋은(쉬운) 도구를 활용한다.)
4. 분석결과 (보고서/회의자료)
 전체 과정에서 '전처리(pre Processing 결측치, 이상치'(값을 따진다.)가 작업 과정에 70~80%를 차지한다.
 빅데이터 관련 분야에 인력이 필요한 부분 중에 하나가 이 전처리 과정에 있기도 하다.

데이터 종류 (정형 Structured Data / 비정형 Unstructured Data)
 정형 : 틀이 잡혀 있는 데이터, 체계화된 데이터 
        안정성이 높지만 유연성이 낮다.
        금융, 제조 등 대부분의 기업의 데이터 (엑셀, CSV...)
        데이터 분석을 할 때는 보통 정형을 분석한다. (우리가 다룰 것은 이 정형이다.)
        관계형 데이터베이스로 관리 가능
        * CSV (Comma Separated Value) 
          쉼표를 기준으로 항목을 구분하여 저장한 데이터를 말한다. 데이터베이스나 표 계산 소프트웨어 데이터를 
          보존하기 위해 이런 형식을 사용한다. CSV 형식의 파일은 텍스트 파일로 보존하여 문서 처리기나
          편집기에서 열람/편집할 수 있다. 수많은 애플리케이션에서 취급하는 범용 형식이기 때문에
          PDA(Personal digital assistant)와 PC 사이에 주소록이나 표의 데이터를 주고 받을 때에도
          데이터 파일을 CSV 형식으로 변환해서 송수신하는 경우가 많다.
         
         (갈수록 비정형의 비율이 커지고 있다.)
 비정형 : 틀이 잡혀 있지 않은, 사전 정의가 없는 다양하고 방대한 데이터
          텍스트(Facebook, Twitter 등에서 작성된 수많은 글들), 이미지, 음원 등

    

데이터베이스란 ??
 데이터는 어떤 것들의 '기록된 정보'이고 이러한 데이터를 관리하기 위해 모아놓은 것을 DataBase라고 한다.

관계형 데이터베이스란 ??
 현재 업무용으로 가장 많이 사용되는 방식이고 역사가 오래 되었음에도 지속적으로 발전해 나가고 있는 데이터베이스이다.
 대표적으로 MySQL, MSSQL, Oracle, IBM(회사 이름이기도 하지만..), Asscess(Office에 들어가는) ...
 열(column)과 행(row)으로 이루어진 2차원 테이블을 중심으로 설계된 데이터베이스이다.
 테이블들이 Key와 Value라는 연결 고리로 이루어져 원하는 데이터를 조회/가공하는 방식의 데이터베이스이다.

계층형 데이터베이스란 ?? (관계형 전에 이러한 방식을 사용했다. - 데이터를 폴더 개념으로)
 Root - Level 1
      - Level 1 - Level 2
                  Level 2 - Level 3

객체지향 데이터베이스란 ?? 
 데이터도 객체 모델로 관리

    객체A    <----->    객체B
      |       객체C      |
    객체D    <----->    객체E

XML 데이터베이스란 ?? (사용되곤 한다.)
 주로 인터넷에서 데이터를 관리하는 용도로 사용된다.
 Python의 dict, Java의 map, Javascript의 json 등 키값과 밸류값으로 이루어져 있다.


SQL ??
 sql은 관계형 데이터베이스 (MySQL, MSSQL, Oracle, IBM, Asscess ...)를 조작하기 위해 만든 표준 언어이다.
 MySQL, Oracle은 서로 지역이 다른 말투라고 이해하면 좋다.
 DBMS과 통신하기 위한 언어이다.
 사용자  ->  SQL(언어를 통해)  ->  DBMS(Oracle, MySQL 등을 통해)  ->  DB (실제 데이터에 접근한다.)



SQL의 특징
 1. 사용하기 쉽다.
 2. 절차가 없는 비절차적 언어이다.
 3. 관계형 DB를 조작한다.
 4. 표준 언어이다.


SQL의 종류
 DML 조작어 Data Manipulation Language (주로 사용)
    SELECT, INSERT, UPDATE, DELETE  (계속 사용하게됨)


 DLL 정의어 Data Definition Language (주로 사용)
    CREATE, ALTER, DROP, RENAME (한 번 만들면 계속 사용)


 DCL 제어어 Data Control Language 
    GRANT(권한), REVOKE


 TCL 트랜젝션 컨트롤 Transaction Control Language
    데이터베이스에서 트랜젝션이란 논리적인 일의 단위를 말한다.
    COMMIT(실행), ROLLBACK(되돌리는)

    COMMIT문은 관계형 데이터베이스 관리 시스템(RDBMS)에서 트랜젝션을 종료하고
    다른 사용자에게 변경된 모든 사항을 보이도록 만드는 문이다.
    일반적으로 트랜잭션 종료 시 해당 업데이트를 확정한다는 의미에서 "커밋"이라고 사용한다.

SQL로 데이터 처리(추출/수집/가공)을 하여 데이터를 검색하고 분석한다.

관계형 데이터베이스의 구성 요소
 1) 테이블 뷰 인덱스 등으로 구성된다.
 2) 데이터를 저장하고 그 데이터들의 관계의 집합이다.
 3) 일관성, 정확성, 신뢰성을 위한 트랜젝션, 무결성 등의 개념이 존재한다.

테이블 : 행(row)과 열(column)로 구성된 저장 단위
        데이터베이스의 다양한 구성 요소 중에 데이터를 담는 그릇이라 할 수 있는 테이블을 가장 많이 사용하게 된다.
        데이터베이스(숲)를 한 마디로 요약하면 테이블(나무)들이 모여 있는 집합이라고 할 수 있다.
        행(row 항목)과 열(column 속성)로 이루어진 엑셀과 비슷하다.


SQL Developer
 1. 접속(왼쪽상단) DB 정보 테이블/뷰 등의 객체 정보가 계층형태로 보여진다.
    DB의 전체 구조를 알 수 있다.

 2. 보고서(왼쪽하단) 데이터 모델링과 구조, 보안, 성능 등 모니터링과 보고서를 확인하는 여역
    주로 DB관리자, 시스템 담당자가 보는 화면으로 초반에는 사용할 일이 거의 없다.

 3. 편집(오른쪽상단) SQL문을 작성하는 편집 영역이다. 이 창에서 SQL문을 작성하게 된다.
    작성할 때 발생되는 문법 오류 등을 알려준다.

 4. 출력(오른쪽하단) SQL문의 실행 결과 등이 출력되는 영역이다.

오늘 사용했던 문법들

SHOW USER;     // User를 보여준다.
ALTER USER HR ACCOUNT UNLOCK IDENTIFIED BY 1234;  // User ID : HR, Password : 1234를 생성한다.
SELECT 
 데이터를 조회하는 데 필요한 거의 모든 기능을 제공한다.
 예) SELECT * FROM JOBS;   (JOBS 폴더에 있는 모든 내용을 보여준다.)
 SELECT를 사용하여 행과 열을 선택하고 테이블과 테이블을 연결할 수 있다.
 SELECT문은 데이터를 조회/분석에 필요한 가장 기본적이고 중요한 SQL구문이다.

 SELECT문은 항상 FROM과 함께 사용된다. 다른 조건 추가가 필요한 경우 WHERE조건절에 기속하고,
 데이터가 출력되는 순서를 조정하려면 ORDER BY를 사용한다.
 (Python은 줄에 엄격하지만 Java와 SQL구문은 줄 띄움에 상관이 없다.)
 SELECT (열이름들 또는 *) FROM (테이블명) [WHERE(조건식)] <- 선택 [ORDER BY(열이름 ASC or DESC)];

 그러니까, 이렇게 줄을 띄워서 입력해도 된다.

 SELECT (열이름들 또는 *)   <- 가져올 열,열들 또는 열 전체를 의미하고
 FROM (테이블명)           <- 어느 테이블로부터 가져올지 결정한다.
 [WHERE(조건식)]   <- 선택사항
 [ORDER BY(열이름 ASC or DESC)];

 1. SQL구문은 모두 (관용적으로) 대문자를 입력한다. (소문자로 입력해도 되긴하다.)
 2. []안의 항목은 선택사항, 그래서 보통 FROM까지 사용하는 경우가 많다.
 3. 구문의 끝은 세미콜론(;)을 입력한다. (생략 가능할 때도 있다.)
 4. 한 줄 또는 여러 줄을 사용할 수 있으면서 아예 줄을 상관하지 않는다. (들여쓰기도 상관하지 않는다.)


SELECT는 단지 선택만 할 뿐 그 결과값이 데이터베이스에 반영되는 것은 아니다.

SELECT *    <- 출력하려는 열이 '모든 열' 이라는 의미이다.
FROM employees;    <- employees라는 테이블로부터 라는 의미이다.

 SELECT명령문 뒤의 나열한 열들의 이름 순으로 조회된다. 
 열들의 이름은 , 를 사용하여 계속 붙일 수 있고 결과는 나열한 순서대로 출력된다.
 모든 열을 대신하여 모든 열의 이름을 적으면 같은 결과가 나오게 된다.


ORDER BY 열이름 [ASC or DESC]   <-  DESC 내림차순
ORDER BY 명령문에 아무 것도 지정하지 않으면 오름차순으로 정렬되기 때문에 
ORDER BY employee_id ASC; 와 같다.


SELECT employee_id, first_name, last_name   <- 출력할 열을 나열하였다.
FROM employees      <- 란 테이블에서 열을 선택한다.
ORDER BY employee_id DESC;     <- employee_id값을 기준으로 내림차순 DESC 정렬 (높은 숫자에서 아래로)
(ORDER BY 열이름, 열이름 DESC, 열이름 ASC;)  이렇게 정렬을 원하는 열을 지정할 수 있다.



중복값 제거하고 출력 DISTINCT
SELECT DISTINCT job_id      <- SELECT다음에 DISTINCT를 입력하면 데이터값이 종류별로 하나씩만 출력된 것을 볼 수 있다.
FROM employees;     라는 테이블에서 열을 선택한다.

별명 사용하기
 SELECT문의 결과를 출력할 때 일반적으로 열이름은 테이블을 정의할 때 명명한 열의 제목을 출력한다.
 원래의 열이름 외에 다른 이름으로 쓰고자 할 때 사용하는 것이 별칭(alies)이다.
 1) 열이름을 임시로 변경하는데 사용된다. (원래 이름이 물리적으로 변경되는 것은 아니다.)
 2) 별칭은 열이름 바로 뒤에 사용되며 AS를 사용한다.
 3) AS는 생략 가능하다.

SELECT employee_id AS 사원번호, first_name AS 이름, last_name AS 성
FROM employees; 
(employee_id가 사원번호로 바뀌고, first_name이 이름으로 바뀌고, last_name이 성으로 바뀌었다.)


데이터 값 결합 - 각 열에 따로 담겨 있는 데이터를 하나로 붙이거나 추가 서식을 붙여 활용할 수 있다 
                || 연결 연산자 2개 (or 2개, shift + \\)
                [열이름] || [열이름]      [열이름] || '문자' (글자를 나타낼 때는 ''를 사용한다.)

SELECT employee_id, first_name || ' ' || last_name     (first_name과 last_name을 붙이고 중간에 ' ' 공백을 넣었다.)
FROM employees;                                        (띄어쓰기를 위해 중간에 ' '를 넣고 다시 ||를 넣는다)


SELECT email || '@' || 'naver.com' AS email    아이디만 있는 이메일 열의 내용을 이렇게,
FROM employees;                                '@'와 뒤에 주소를 입력해서 출력하도록 할 수 있다.



데이터 값의 연산

SELECT employee_id AS 사원번호,      이름을 정해주고 이렇게 정리하여 출력할 수 있다.
       salary AS 급여,
       salary+500 AS 인상급여,
       salary-100 AS 인하급여
FROM employees;



조건절을 활용한 데이터 검색 WHERE
행의 특정 데이터 값을 조회하거나 비교하여 연산 처리하는 방법
'어디에서 어떻게' 가져올지를 결정한다. WHERE는 FROM 다음에 위치하며 조건식을 포함한다.
 1) 조건을 지정하고
 2) FROM절 다음에 위치한다.
 3) 조건절에 비교연산자, 논리연산자, 표현식, 문자, 숫자 등을 사용한다.

SELECT 열이름
FROM 테이블이름
WHERE 조건;


SELECT *
FROM employees
WHERE employee_id = 100;     <- 조건이 숫자 _id = 100 인 한 사람이 나왔다.


SELECT *
FROM employees
WHERE first_name = 'David';      <- 조건이 문자 'David' 이름을 가진 사람이 3명이 나왔다.

  # 'David'과 'david'은 다른 의미이다. 
  # 구문을 입력할 때 대소문자 구분을 하지 않지만 데이터를 검색할 경우 모두 구분한다.


SELECT *
FROM employees 
WHERE employee_id >= 100;      _id 가 100이상인 사람들만 조회하도록





BETWEEN a AND B    두 값의 범위에 해당하는 행들을 검색

SELECT *
FROM employees
WHERE salary BETWEEN 10000 AND 20000;    salary가 10000~20000범위에 있는 데이터를 출력




IN 조회하고자 하는 데이터 값이 여러 개일 때 사용한다
=과 비슷하지만 =은 하나만 '지정'할 수 있고 IN은 '여러 개를 지정'할 수 있다.

SELECT *
FROM employees 
WHERE salary IN(10000,17000,24000);   salary가 지정한 3개의 값인 데이터만 출력된다



LIKE 조건값이 명확하지 않을 때 '~와 같은'
 1) %와 _ 같은 기호 연산자와 함께 사용된다.
 2) 조건에는 문자나 숫자가 포함된다.
 3) %는 모든 문자의 의미이고 _ 는 '한 글자'를 의미한다.

SELECT *
FROM employees
WHERE job_id LIKE 'AD%';     job_id의 값이 AD문자로 시작하는 모든 데이터를 출력한다.

SELECT *
FROM employees
WHERE job_id LIKE 'AD___';   job_id의 값이 AD문자로 시작하며 이어서 그 뒤가 3글자인 데이터만 출력한다.   





IS NULL 데이터의 값이 null인 경우(아무런 값이 입력되지 않은)를 조회할 때 사용한다.
null은 공백도 아니고 0도 아니다.(공백은 문자이다.)

SELECT *
FROM employees
WHERE manager_id IS NULL;     manager_id에 아무런 값이 입력되지 않은 데이터를 출력하라는 의미





AND 는 주어진 조건들을 모두 만족하는 데이터를 출력한다.

SELECT *
FROM employees 
WHERE salary > 4000
AND   job_id = 'IT_PROG';        salary가 4000이상이면서,  job_id의 값이 'IT_PROG'인 데이터를 출력한다.





OR는 주어진 조건 중 하나만 만족해도 출력하라는 의미에서

SELECT *
FROM employees
WHERE salary > 4000
OR    job_id = 'IT_PROG';      salary값이 4000이상인 데이터와 job_id값이 'IT_PROG'인 데이터를 출력한다.





NOT, !=, <>  같지 않다 (ISO 표준에서는 <>, 컴퓨터에서는 != 를 더 많이 사용한다.)

SELECT *
FROM employees
WHERE job_id <> 'IT_PROG';

                            job_id의 값이 'IT_PROG'가 아닌 데이터를 출력한다.
SELECT *
FROM employees
WHERE job_id != 'IT_PROG';



SELECT *
FROM employees
WHERE manager_id IS NOT NULL;   manager_id의 값이 입력되어 있는 데이터를 출력한다.


